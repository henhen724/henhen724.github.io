import fetch, { Headers, RequestInit } from 'node-fetch'
import { authorize, getAccessToken, getConfig, instance } from './main'
import config from './config'
import { ScoutSubscription } from './ScoutSubscription'
import { SubscriptionClient } from 'subscriptions-transport-ws'
import * as ws from 'ws'
import { delayPromise } from './utilities/delayPromise'

let subscriptionsClient: SubscriptionClient = null

function normalizeHeaders(headers: Headers | string[] | { [index: string]: string }): Headers {
  let normalized = new Headers()

  if (!headers) {
    return normalized
  }

  if (headers instanceof Headers) {
    headers.forEach((value, name) => normalized.append(name, value))
  }
  else if (Array.isArray(headers)) {
    headers.forEach(header => {
      let parts = header.split(':', 2)
      normalized.set(parts[0].trim(), parts[1].trim())
    })
  }
  else {
    Object.keys(headers).forEach(headerName => normalized.set(headerName, headers[headerName]))
  }

  return normalized
}

export async function signedFetch(url: string, options?: RequestInit) {
  let accessToken = getAccessToken()
  let { clientId } = getConfig()
  options = (options || {}) as RequestInit

  let headers = normalizeHeaders(options.headers)
  headers.set('Authorization', `Bearer ${accessToken}`)

  if (clientId) {
    headers.set('Scout-App', clientId)
  }

  options.headers = headers

  return fetch(url, options)
}

async function performGraphQuery(query: string, variables: object = {}, extract: (data: any) => any = (d => d), language: string = 'en-US', retries: number = 0) {
  if (retries > instance.config.maxRetries) {
    throw new Error('Max retries exceeded')
  }

  const url = `${config.baseUri}/graph`

  let response = null

  try {
    response = await signedFetch(url, {
      method: 'POST',
      body: JSON.stringify({
        query,
        variables: variables || {}
      }),
      headers: {
        'Accept': `application/com.scoutsdk.graph+json; version=${config.graphVersion}; charset=utf8`,
        'Accept-Language': language,
        'Content-Type': 'application/json'
      }
    })
  }
  catch (e) {
    await delayPromise(Math.pow(2, Math.min(retries, 4)) * 1000)
    return performGraphQuery(query, variables, extract, language, ++retries)
  }

  if (response.status === 401) {
    await authorize()
    return performGraphQuery(query, variables, extract, language, ++retries)
  }

  let json = await response.json()

  if (json.data && (!json.errors || json.errors.length === 0)) {
    return extract ? extract(json.data) : json.data
  }
  else if (json.errors && json.errors.length > 0) {
    let firstError = json.errors[0]
    let err = new Error(firstError.message) as any
    err.errors = json.errors
    err.reason = firstError.data ? firstError.data.reason : 'UNKNOWN'
    throw err
  }
  else {
    let err = new Error("Unknown error occurred") as any
    err.errors = []
    err.reason = 'UNKNOWN'
    throw err
  }
}

export function graphQuery(query: string, variables: object = {}, extract: (data: any) => any = (d => d), language: string = 'en-US') {
  return performGraphQuery(query, variables, extract, language)
}

export function graphSubscription(query: string, variables: object = {}, extract: (data: any) => any = (d => d), language: string = 'en-US') : ScoutSubscription {
  let accessToken = getAccessToken()

  // Set up the subscriptions client using the ws websocket implelementation if it doesn't already exist
  if (!subscriptionsClient) {
    subscriptionsClient = new SubscriptionClient(`${config.baseUri}/graph?access_token=${accessToken}&version=${config.graphVersion}`, {
      reconnect: true
    }, ws)
  }

  // Create a subscription request (do not execute it yet, though)
  let request = subscriptionsClient.request({
    query: `subscription ${query}`,
    variables,
    language
  })

  // Set up and execute the manager for this subscription
  let subscription = new ScoutSubscription(request, extract)

  // Initialize the subscription with the most recent data
  // (so the user doesn't have to wait until the data changes)
  graphQuery(query, variables, extract, language)
    .then((data: any) => subscription.emit('data', data))
    .catch((err: Error) => subscription.emit('error', err))

  return subscription
}
